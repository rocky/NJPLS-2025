<h1>Things to Keep in Mind when Developing a Compiler</h1>
<section>
    <ul>
      <li>Support <em>useful</em> position information all of the kinds of containers.</li>
      <li>Have a way to verify that the source text matches text in compiled code.</li>
      <li>Use better granularity in positions than a line number: line + column (or offset), or better: ranges.</li>
      <li>Adding a debugger generally forces more accurate positions.</li>
      <li>If you do write a debugger, please don't invent a new command-language and terminology.</li>
      <li>If you are using bytecode consider adding a <i>DEBUG</i> opcode which runs a "breakpoint" callback.</li>
    </ul>

<aside class="notes">
  <p>
    Here are things to keep in mind when developing a compiler to assist run-time debugging.
  </p>

  <p>Keep in mind all of the different kinds of containers and see if your position information mechanism gives useful information for all of these.
  </p>

  <p>Have a way to verify the source text that the user sees is the same source text the compiler used in compiling.</p>

  <p>Use better granularity in positions than a line number. A line
  and column (or character offset) is better. But better yet is to
  note a source-text range or source-text fragment.</p>

  <p>Provide a debugger API and write a debugger. Adding a debugger generally forces more accurate positions.</p>

  <p>If you do write a debugger, please don't invent a new
  command-language and terminology. Please follow one of the existing
  debuggers that exist. I have used <em>gdb</em> as my model.</p>

  <p>If you're interpreters runs bytecode, consider adding a DEBUG opcode which runs a "breakpoint" callback.
    <div style="color: blue; background-color:
		LightYellow">
      [NEXT] 14.1 ‚ü∂ 15.1
    </div>
  </p>
</aside>
</section>
